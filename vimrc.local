nnoremap <Leader>! :Dispatch<cr>
nnoremap <Leader># :CtrlPLine<cr>
nnoremap <Leader>( :tabprev<cr>
nnoremap <Leader>) :tabnext<cr>
nnoremap <Leader>@ :CtrlPTag<cr>
nnoremap <Leader>` :CtrlPChange<cr>
nnoremap <Leader>1 :set background=dark<cr> :colorscheme solarized<cr>
nnoremap <Leader>2 :set background=light<cr> :colorscheme solarized<cr>
nnoremap <Leader>3 :set guifont=Anonymous\ Pro\ For\ Powerline:h14<cr>
nnoremap <Leader>4 :set guifont=Anonymous\ Pro\ For\ Powerline:h28<cr>
nnoremap <Leader>5 :set transparency=3<cr>
nnoremap <Leader>6 :set transparency=63<cr>
nnoremap <Leader><Leader> <C-^>
nnoremap <Leader>P :CtrlPMixed<cr>
nnoremap <Leader>b :CtrlPBuffer<cr>
nnoremap <Leader>d :CtrlPDir<cr>
nnoremap <Leader>e :e <C-r>=expand('%:h') . '/'<cr>
nnoremap <Leader>f :CtrlPCurFile<cr>
nnoremap <Leader>s :SyntasticToggleMode<cr>
nnoremap <Leader>t :CtrlPBufTag<cr>
nnoremap <Leader>z zMzv

vnoremap <Leader>so y:execute @@<cr>
nnoremap <Leader>so ^vg_y:execute @@<cr>

nnoremap <Leader>sr vip:!sort<cr>
vnoremap <Leader>sr :!sort<cr>

function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc

nmap <Leader>sy :call <SID>SynStack()<cr>
nnoremap <silent> <Leader>/ :execute 'vimgrep /'.@/.'/g %'<cr>:copen<cr>
nnoremap <silent> <Leader>? :execute 'vimgrep /'.@/.'/g *'<cr>:copen<cr>

nnoremap <silent> <C-w>+ :exe "resize " . (winheight(0) * 3/2)<cr>
nnoremap <silent> <C-w>- :exe "resize " . (winheight(0) * 2/3)<cr>
nnoremap <silent> <C-w>< :exe "vertical resize " . (winwidth(0) * 2/3)<cr>
nnoremap <silent> <C-w>> :exe "vertical resize " . (winwidth(0) * 3/2)<cr>

function! WinMove(key)
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr())
    if (match(a:key,'[jk]'))
      wincmd v
    else
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction

noremap <silent> <C-w><C-h> :call WinMove('h')<cr>
noremap <silent> <C-w><C-j> :call WinMove('j')<cr>
noremap <silent> <C-w><C-k> :call WinMove('k')<cr>
noremap <silent> <C-w><C-l> :call WinMove('l')<cr>

autocmd FileType css           setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType haskell       setlocal omnifunc=necoghc#omnifunc
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType java          setlocal omnifunc=javacomplete#Complete
autocmd FileType javascript    setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python        setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml           setlocal omnifunc=xmlcomplete#CompleteTags

let g:airline_left_sep        = ''
let g:airline_powerline_fonts = 1
let g:airline_right_sep       = ''
let g:haskell_conceal = 1
let g:syntastic_error_symbol         = '✗'
let g:syntastic_java_javac_classpath = '.:.shake:.shake/src:.shake/test:lib/*.jar'
let g:syntastic_warning_symbol       = '⚠'
let g:vim_tags_use_vim_dispatch = 1

let g:syntastic_mode_map = {
      \ 'mode': 'passive',
      \ 'active_filetypes': [],
      \ 'passive_filetypes': [] }

autocmd BufNewFile,BufRead Shakefile set filetype=haskell
autocmd BufReadPost fugitive://* set bufhidden=delete

autocmd FileType haskell noremap <buffer>__ :GhcModTypeClear<cr>
autocmd FileType haskell noremap <buffer>_t :GhcModType!<cr>
autocmd FileType haskell noremap <buffer>_T :GhcModTypeInsert!<cr>
autocmd FileType haskell noremap <buffer>_i :GhcModInfo!<cr>
autocmd FileType haskell noremap <buffer>_I :GhcModInfoPreview!<cr>

autocmd FileType go            setl commentstring=//\ %s
autocmd FileType masm          setl commentstring=;\ %s
autocmd FileType scheme,racket setl commentstring=;\ %s

autocmd FileType php set tabstop=4
autocmd FileType php set shiftwidth=4

if executable('lein')
  autocmd FileType clojure
        \ setl makeprg=lein\ exec\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('coffee')
  autocmd FileType coffee
        \ setl makeprg=coffee\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('elixir')
  autocmd FileType elixir
        \ setl makeprg=elixir\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('idris')
  autocmd FileType idris
        \ setl makeprg=idris\ \"%:p\"\ --exec\ main |
        \ setl errorformat=%+I%.%#
endif

if executable('node')
  autocmd FileType javascript
        \ setl makeprg=node\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('lli')
  autocmd FileType llvm
        \ setl makeprg=lli\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('tpico')
  autocmd FileType pico
        \ setl makeprg=tpico\ -b\ -i\ -s\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('racket')
  autocmd FileType racket,scheme
        \ setl makeprg=racket\ \"%:p\" |
        \ setl errorformat=%+I%.%#
end

if executable('potion')
  autocmd FileType potion
        \ setl makeprg=potion\ \"%:p\" |
        \ setl errorformat=%+I%.%#
endif

if executable('go')
  autocmd FileType go
        \ if expand('%') =~# 'Test.go$' |
        \   setl makeprg=go\ test\ \"%:p\" |
        \ else |
        \   setl makeprg=go\ run\ \"%:p\" |
        \   setl errorformat=%+I%.%# |
        \ endif
endif

if executable('runhaskell')
  autocmd FileType haskell
        \ if expand('%') =~# 'Spec.hs$' |
        \   setl makeprg=hspec\ \"%:p\" |
        \   setl errorformat=%+I%.%# |
        \ else |
        \   setl makeprg=runhaskell\ \"%:p\" |
        \   setl errorformat=%+I%.%# |
        \ endif
endif

if executable('ruby')
  autocmd FileType ruby
        \ if expand('%') =~# '_test\.rb$' |
        \   compiler rubyunit | setl makeprg=testrb\ \"%:p\" |
        \ elseif expand('%') =~# '_spec\.rb$' |
        \   compiler rspec | setl makeprg=rspec\ \"%:p\" |
        \ else |
        \   compiler ruby | setl makeprg=ruby\ -w\ \"%:p\" |
        \   setl errorformat=%+I%.%# |
        \ endif
endif


autocmd FileType markdown
      \ setl makeprg=open\ -a\ Marked\ \"%:p\" |
      \ setl errorformat=%+I%.%#

autocmd FileType swift
      \ setl makeprg=xcrun\ swift\ -i\ \"%:p\" |
      \ setl errorformat=%+I%.%#
