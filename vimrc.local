nnoremap <Leader>! :Dispatch<cr>
nnoremap <Leader>( :tabprev<cr>
nnoremap <Leader>) :tabnext<cr>
nnoremap <Leader>1 :set background=dark<cr> :colorscheme solarized<cr>
nnoremap <Leader>2 :set background=light<cr> :colorscheme solarized<cr>
nnoremap <Leader>3 :set guifont=Anonymous\ Pro\ For\ Powerline:h18<cr>
nnoremap <Leader>4 :set guifont=creep:h16<cr>:source ~/.vim/creep/creep.vim<cr>
" nnoremap <Leader>4 :set guifont=Anonymous\ Pro\ For\ Powerline:h28<cr>
nnoremap <Leader>5 :set transparency=3<cr>
nnoremap <Leader>6 :set transparency=63<cr>
nnoremap <Leader><Leader> <C-^>
nnoremap <Leader>z zMzv

vnoremap <Leader>So y:execute @@<cr>
nnoremap <Leader>So ^vg_y:execute @@<cr>

nnoremap <Leader>Sr vip:!sort<cr>
vnoremap <Leader>Sr :!sort<cr>

function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc
nnoremap <Leader>Sy :call <SID>SynStack()<cr>

nnoremap <silent> <C-w>+ :exe "resize " . (winheight(0) * 3/2)<cr>
nnoremap <silent> <C-w>- :exe "resize " . (winheight(0) * 2/3)<cr>
nnoremap <silent> <C-w>< :exe "vertical resize " . (winwidth(0) * 2/3)<cr>
nnoremap <silent> <C-w>> :exe "vertical resize " . (winwidth(0) * 3/2)<cr>

function! WinMove(key)
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr())
    if (match(a:key,'[jk]'))
      wincmd v
    else
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction

nnoremap <silent> <Leader>/ :exe 'Ag '.@/.' %'<CR>
nnoremap <silent> <Leader>? :exe 'Ag '.@/.' *'<CR>
" nnoremap <silent> <Leader>p :exe 'FZF'<CR>
nnoremap <silent> <Leader>e :exe 'FZF ' . expand('%:h')<CR>
nnoremap <silent> <Leader>m :Mru<CR>

command! FZFSplit call fzf#run({
      \ 'tmux_height': '40%',
      \ 'sink':        'sp' })

command! FZFVSplit call fzf#run({
      \ 'tmux_width': winwidth('.') / 2,
      \ 'sink':       'vsp' })

command! FZFTab call fzf#run({
      \ 'sink': 'tabe' })

function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

nnoremap <silent> <Leader><Enter> :call fzf#run({
      \ 'source':  reverse(<sid>buflist()),
      \ 'sink':    function('<sid>bufopen'),
      \ 'options': '+m',
      \ 'down':    len(<sid>buflist()) + 2 })<CR>

command! Mru call fzf#run({
      \ 'source': v:oldfiles,
      \ 'sink': 'e',
      \ 'options': '-m -x +s',
      \ 'down': '40%' })

function! s:tags_sink(line)
  let parts = split(a:line, '\t\zs')
  let excmd = matchstr(parts[2:], '^.*\ze;"\t')
  execute 'silent e' parts[1][:-2]
  let [magic, &magic] = [&magic, 0]
  execute excmd
  let &magic = magic
endfunction

function! s:tags()
  if empty(tagfiles())
    echohl WarningMsg
    echom 'Preparing tags'
    echohl None
    call system('ctags -R')
  endif

  call fzf#run({
        \ 'source':  'cat '.join(map(tagfiles(), 'fnamemodify(v:val, ":S")')).
        \            '| grep -v ^!',
        \ 'options': '+m -d "\t" --with-nth 1,4.. -n 1 --tiebreak=index',
        \ 'down':    '40%',
        \ 'sink':    function('s:tags_sink') })
endfunction

if executable('ag')
  function! s:ag_to_qf(line)
    let parts = split(a:line, ':')
    return {'filename': parts[0], 'lnum': parts[1], 'col': parts[2],
          \ 'text': join(parts[3:], ':')}
  endfunction

  function! s:ag_handler(lines)
    if len(a:lines) < 2 | return | endif

    let cmd = get({'ctrl-x': 'split',
          \ 'ctrl-v': 'vertical split',
          \ 'ctrl-t': 'tabe'}, a:lines[0], 'e')
    let list = map(a:lines[1:], 's:ag_to_qf(v:val)')

    let first = list[0]
    execute cmd escape(first.filename, ' %#\')
    execute first.lnum
    execute 'normal!' first.col.'|zz'

    if len(list) > 1
      call setqflist(list)
      copen
      wincmd p
    endif
  endfunction

  command! -nargs=* Ag call fzf#run({
        \ 'source':  printf('ag --nogroup --column --color "%s"',
        \                   escape(empty(<q-args>) ? '^(?=.)' : <q-args>, '"\')),
        \ 'sink*':   function('<sid>ag_handler'),
        \ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x --delimiter : --nth 4.. '.
        \            '--multi --bind ctrl-a:select-all,ctrl-d:deselect-all '.
        \            '--color hl:68,hl+:110',
        \ 'down':    '50%' })
endif

if executable('tmux')
  " autocmd VimEnter * silent !tmux set status off
  " autocmd VimLeave * silent !tmux set status on
endif

if executable('xiki')
  let $XIKI_DIR = "~/.xiki"
  source ~/.xiki/etc/vim/xiki.vim
endif

if executable('md5')
  command! -range Md5 :echo system('echo '.shellescape(join(getline(<line1>, <line2>), '\n')) . '| md5')
endif

noremap <silent> <C-w><C-h> :call WinMove('h')<cr>
noremap <silent> <C-w><C-j> :call WinMove('j')<cr>
noremap <silent> <C-w><C-k> :call WinMove('k')<cr>
noremap <silent> <C-w><C-l> :call WinMove('l')<cr>

autocmd FileType css           setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType haskell       setlocal omnifunc=necoghc#omnifunc
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType java          setlocal omnifunc=javacomplete#Complete
autocmd FileType javascript    setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python        setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml           setlocal omnifunc=xmlcomplete#CompleteTags

let g:airline_left_sep        = ''
let g:airline_powerline_fonts = 1
let g:airline_right_sep       = ''
" let g:haskell_conceal = 1
let g:hdevtools_options = '-g-isrc -g-Wall -g-fwarn-typed-hole -g-fdefer-type-errors -g-XPartialTypeSignatures'
let g:paredit_mode = 0
let g:paredit_shortmaps = 0
let g:paredit_smartjump = 1
let g:syntastic_error_symbol         = '✗'
let g:syntastic_java_javac_classpath = '.:.shake:.shake/src:.shake/test:lib/*.jar'
let g:syntastic_haskell_hdevtools_args = '-g-isrc -g-Wall -g-fwarn-typed-holes -g-XPartialTypeSignatures'
let g:syntastic_warning_symbol       = '⚠'
let g:vim_tags_use_vim_dispatch = 1

let g:syntastic_mode_map = {
      \ 'mode': 'passive',
      \ 'active_filetypes': [],
      \ 'passive_filetypes': [] }

autocmd BufNewFile,BufRead *.cljx set filetype=clojure
autocmd BufNewFile,BufRead *.nix set filetype=nix
autocmd BufNewFile,BufRead nginx.conf set filetype=nginx
autocmd BufNewFile,BufRead Shakefile set filetype=haskell
autocmd BufReadPost fugitive://* set bufhidden=delete

" autocmd FileType haskell noremap <buffer>__ :GhcModTypeClear<cr>
" autocmd FileType haskell noremap <buffer>_t :GhcModType!<cr>
" autocmd FileType haskell noremap <buffer>_T :GhcModTypeInsert!<cr>
" autocmd FileType haskell noremap <buffer>_i :GhcModInfo!<cr>
" autocmd FileType haskell noremap <buffer>_I :GhcModInfoPreview!<cr>

autocmd FileType haskell nnoremap <buffer> _t :HdevtoolsType<cr>
autocmd FileType haskell nnoremap <buffer> __ :HdevtoolsClear<cr>

autocmd FileType coq           setl commentstring=(*\ %s\ *)
autocmd FileType go            setl commentstring=//\ %s
autocmd FileType masm          setl commentstring=;\ %s
autocmd FileType scheme,racket setl commentstring=;\ %s

autocmd FileType php    setl shiftwidth=4 tabstop=4
autocmd FileType python setl shiftwidth=4 tabstop=4

if executable('lein')
  autocmd FileType clojure
        \ setl makeprg=lein\ exec\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('coffee')
  autocmd FileType coffee
        \ setl makeprg=coffee\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('coqtop')
  autocmd FileType coq
        \ setl makeprg=coqtop\ -batch\ -l\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('elixir')
  autocmd FileType elixir
        \ if expand('%') =~# '_test\.exs' |
        \   if filereadable('mix.exs') |
        \     setl makeprg=mix\ test\ %:p |
        \   else |
        \     setl makeprg=elixir\ %:p |
        \   endif |
        \ else |
        \   setl makeprg=elixir\ %:p |
        \ endif |
        \ setl errorformat=%+I%.%#
endif

if executable('idris')
  autocmd FileType idris
        \ setl makeprg=idris\ %:p\ --exec\ main |
        \ setl errorformat=%+I%.%#
endif

if executable('node')
  autocmd FileType javascript
        \ setl makeprg=node\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('lli')
  autocmd FileType llvm
        \ setl makeprg=lli\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('tpico')
  autocmd FileType pico
        \ setl makeprg=tpico\ -b\ -i\ -s\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('racket')
  autocmd FileType racket,scheme
        \ setl makeprg=racket\ %:p |
        \ setl errorformat=%+I%.%#
end

if executable('ocaml')
  autocmd FileType ocaml
        \ setl makeprg=ocaml\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('potion')
  autocmd FileType potion
        \ setl makeprg=potion\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('psc')
  autocmd FileType purescript
        \ setl makeprg=psc\ --main\ %:p\ \|\ node |
        \ setl errorformat=%+I%.%#
endif

if executable('go')
  autocmd FileType go
        \ setl noexpandtab |
        \ setl nolist |
        \ if expand('%') =~# '_test\.go$' |
        \   setl makeprg=go\ test\ %:p |
        \ else |
        \   setl makeprg=go\ run\ %:p |
        \   setl errorformat=%+I%.%# |
        \ endif
endif

if executable('runhaskell')
  autocmd FileType haskell
        \ if expand('%') =~# 'Spec\.hs$' |
        \   setl makeprg=hspec\ %:p |
        \   setl errorformat=%+I%.%# |
        \ else |
        \   setl makeprg=runhaskell\ %:p |
        \   setl errorformat=%+I%.%# |
        \ endif
endif

if executable('ruby')
  autocmd FileType ruby
        \ if expand('%') =~# '_test\.rb$' |
        \   compiler rubyunit | setl makeprg=testrb\ %:p |
        \ elseif expand('%') =~# '_spec\.rb$' |
        \   compiler rspec | setl makeprg=rspec\ %:p |
        \ else |
        \   compiler ruby | setl makeprg=ruby\ -w\ %:p |
        \   setl errorformat=%+I%.%# |
        \ endif
endif


autocmd FileType markdown
      \ setl makeprg=open\ -a\ Marked\ %:p |
      \ setl errorformat=%+I%.%#

autocmd FileType swift
      \ setl makeprg=xcrun\ swift\ -i\ %:p |
      \ setl errorformat=%+I%.%#

command! FileDispatch execute 'FocusDispatch ' . join(map(split(&makeprg), 'expand(v:val)'))
