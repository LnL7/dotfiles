nnoremap <Leader>! :Dispatch<cr>
nnoremap <Leader>( :tabprev<cr>
nnoremap <Leader>) :tabnext<cr>
nnoremap <Leader>1 :set background=dark<cr> :colorscheme solarized<cr>
nnoremap <Leader>2 :set background=light<cr> :colorscheme solarized<cr>
nnoremap <Leader>3 :set guifont=Anonymous\ Pro\ For\ Powerline:h18<cr>
nnoremap <Leader>4 :set guifont=creep:h16<cr>:source ~/.vim/creep/creep.vim<cr>
" nnoremap <Leader>4 :set guifont=Anonymous\ Pro\ For\ Powerline:h28<cr>
nnoremap <Leader>5 :set transparency=3<cr>
nnoremap <Leader>6 :set transparency=63<cr>
nnoremap <Leader><Leader> <C-^>
nnoremap <Leader>z zMzv

vnoremap <Leader>So y:execute @@<cr>
nnoremap <Leader>So ^vg_y:execute @@<cr>

nnoremap <Leader>Sr vip:!sort<cr>
vnoremap <Leader>Sr :!sort<cr>

function! <SID>SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunc
nnoremap <Leader>Sy :call <SID>SynStack()<cr>

nnoremap <silent> <C-w>+ :exe "resize " . (winheight(0) * 3/2)<cr>
nnoremap <silent> <C-w>- :exe "resize " . (winheight(0) * 2/3)<cr>
nnoremap <silent> <C-w>< :exe "vertical resize " . (winwidth(0) * 2/3)<cr>
nnoremap <silent> <C-w>> :exe "vertical resize " . (winwidth(0) * 3/2)<cr>

function! WinMove(key)
  let t:curwin = winnr()
  exec "wincmd ".a:key
  if (t:curwin == winnr())
    if (match(a:key,'[jk]'))
      wincmd v
    else
      wincmd s
    endif
    exec "wincmd ".a:key
  endif
endfunction

nnoremap <silent> <Leader>/ :exe 'FZFAg '.@/.' %'<CR>
nnoremap <silent> <Leader>? :exe 'FZFAg '.@/.' *'<CR>
nnoremap <silent> <Leader>e :exe 'FZF ' . expand('%:h')<CR>
nnoremap <silent> <Leader>b :FZFBuffers<CR>
nnoremap <silent> <Leader>s :FZFSplit<CR>
nnoremap <silent> <Leader>v :FZFVSplit<CR>

command! FZFSplit call fzf#run({
      \ 'tmux_height': '40%',
      \ 'sink': 'sp' })

command! FZFVSplit call fzf#run({
      \ 'tmux_width': winwidth('.') / 2,
      \ 'sink': 'vsp' })

command! FZFTab call fzf#run({
      \ 'sink': 'tabe' })

function! BufferHandler(b)
  let keys = split(a:b, ':\t')
  exec 'buf' . keys[0]
endfunction

function! BufferCommand()
  let buffers = filter(range(1, bufnr('$')), 'buflisted(v:val)')
  return map(buffers, 'v:val . ":\t" . bufname(v:val)')
endfunction

command! FZFBuffers call fzf#run({
      \ 'source': BufferCommand(),
      \ 'sink': function('BufferHandler'),
      \ 'options': '-m' })

function! LineHandler(l)
  let keys = split(a:l, ':\t')
  exec 'buf ' . keys[0]
  exec keys[1]
  normal! ^zz
endfunction

function! LineCommand()
  let res = []
  for b in filter(range(1, bufnr('$')), 'buflisted(v:val)')
    call extend(res, map(getbufline(b,0,"$"), 'b . ":\t" . (v:key + 1) . ":\t" . v:val '))
  endfor
  return res
endfunction

command! FZFLines call fzf#run({
      \ 'source':  LineCommand(),
      \ 'sink': function('LineHandler'),
      \ 'options': '--extended --nth=3..,',
      \ 'tmux_height': '60%' })

command! FZFMru call fzf#run({
      \ 'source': v:oldfiles,
      \ 'sink': 'e ',
      \ 'options': '-m' })

function! TagCommand()
  return substitute('awk _!/^!/ { print \$1 }_ ', '_', "'", 'g') .
        \ join(tagfiles(), ' ')
endfunction

command! FZFTag call fzf#run({
      \ 'source': TagCommand(),
      \ 'sink': 'tag' })

if executable('ag')
  command! -nargs=1 FZFAg call fzf#run({
        \ 'source': Arghandler(<f-args>),
        \ 'sink': function('AgHandler'),
        \ 'options': '-m' })

  function! AgHandler(l)
    let keys = split(a:l,':')
    execute 'tabe +' . keys[-2] . ' ' . escape(keys[-1], ' ')
  endfunction

  function! Arghandler(l)
    return "ag -i " . a:l . " | sed 's@\\(.[^:]*\\):\\(.[^:]*\\):\\(.*\\)@\\3:\\2:\\1@' "
  endfunction
endif

if executable('tmux')
  " autocmd VimEnter * silent !tmux set status off
  " autocmd VimLeave * silent !tmux set status on
endif

if executable('xiki')
  let $XIKI_DIR = "~/.xiki"
  source ~/.xiki/etc/vim/xiki.vim
endif

if executable('md5')
  command! -range Md5 :echo system('echo '.shellescape(join(getline(<line1>, <line2>), '\n')) . '| md5')
endif

noremap <silent> <C-w><C-h> :call WinMove('h')<cr>
noremap <silent> <C-w><C-j> :call WinMove('j')<cr>
noremap <silent> <C-w><C-k> :call WinMove('k')<cr>
noremap <silent> <C-w><C-l> :call WinMove('l')<cr>

autocmd FileType css           setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType haskell       setlocal omnifunc=necoghc#omnifunc
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType java          setlocal omnifunc=javacomplete#Complete
autocmd FileType javascript    setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python        setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml           setlocal omnifunc=xmlcomplete#CompleteTags

let g:airline_left_sep        = ''
let g:airline_powerline_fonts = 1
let g:airline_right_sep       = ''
" let g:haskell_conceal = 1
let g:paredit_mode = 0
let g:paredit_shortmaps = 0
let g:paredit_smartjump = 1
let g:syntastic_error_symbol         = '✗'
let g:syntastic_java_javac_classpath = '.:.shake:.shake/src:.shake/test:lib/*.jar'
let g:syntastic_warning_symbol       = '⚠'
let g:vim_tags_use_vim_dispatch = 1

let g:syntastic_mode_map = {
      \ 'mode': 'passive',
      \ 'active_filetypes': [],
      \ 'passive_filetypes': [] }

autocmd BufNewFile,BufRead *.cljx set filetype=clojure
autocmd BufNewFile,BufRead *.nix set filetype=nix
autocmd BufNewFile,BufRead nginx.conf set filetype=nginx
autocmd BufNewFile,BufRead Shakefile set filetype=haskell
autocmd BufReadPost fugitive://* set bufhidden=delete

autocmd FileType haskell noremap <buffer>__ :GhcModTypeClear<cr>
autocmd FileType haskell noremap <buffer>_t :GhcModType!<cr>
autocmd FileType haskell noremap <buffer>_T :GhcModTypeInsert!<cr>
autocmd FileType haskell noremap <buffer>_i :GhcModInfo!<cr>
autocmd FileType haskell noremap <buffer>_I :GhcModInfoPreview!<cr>

autocmd FileType coq           setl commentstring=(*\ %s\ *)
autocmd FileType go            setl commentstring=//\ %s
autocmd FileType masm          setl commentstring=;\ %s
autocmd FileType scheme,racket setl commentstring=;\ %s

autocmd FileType php set tabstop=4
autocmd FileType php set shiftwidth=4

if executable('lein')
  autocmd FileType clojure
        \ setl makeprg=lein\ exec\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('coffee')
  autocmd FileType coffee
        \ setl makeprg=coffee\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('coqtop')
  autocmd FileType coq
        \ setl makeprg=coqtop\ -batch\ -l\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('elixir')
  autocmd FileType elixir
        \ if expand('%') =~# '_test\.exs' |
        \   if filereadable('mix.exs') |
        \     setl makeprg=mix\ test\ %:p |
        \   else |
        \     setl makeprg=elixir\ %:p |
        \   endif |
        \ else |
        \   setl makeprg=elixir\ %:p |
        \ endif |
        \ setl errorformat=%+I%.%#
endif

if executable('idris')
  autocmd FileType idris
        \ setl makeprg=idris\ %:p\ --exec\ main |
        \ setl errorformat=%+I%.%#
endif

if executable('node')
  autocmd FileType javascript
        \ setl makeprg=node\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('lli')
  autocmd FileType llvm
        \ setl makeprg=lli\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('tpico')
  autocmd FileType pico
        \ setl makeprg=tpico\ -b\ -i\ -s\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('racket')
  autocmd FileType racket,scheme
        \ setl makeprg=racket\ %:p |
        \ setl errorformat=%+I%.%#
end

if executable('ocaml')
  autocmd FileType ocaml
        \ setl makeprg=ocaml\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('potion')
  autocmd FileType potion
        \ setl makeprg=potion\ %:p |
        \ setl errorformat=%+I%.%#
endif

if executable('go')
  autocmd FileType go
        \ if expand('%') =~# 'Test\.go$' |
        \   setl makeprg=go\ test\ %:p |
        \ else |
        \   setl makeprg=go\ run\ %:p |
        \   setl errorformat=%+I%.%# |
        \ endif
endif

if executable('runhaskell')
  autocmd FileType haskell
        \ if expand('%') =~# 'Spec\.hs$' |
        \   setl makeprg=hspec\ %:p |
        \   setl errorformat=%+I%.%# |
        \ else |
        \   setl makeprg=runhaskell\ %:p |
        \   setl errorformat=%+I%.%# |
        \ endif
endif

if executable('ruby')
  autocmd FileType ruby
        \ if expand('%') =~# '_test\.rb$' |
        \   compiler rubyunit | setl makeprg=testrb\ %:p |
        \ elseif expand('%') =~# '_spec\.rb$' |
        \   compiler rspec | setl makeprg=rspec\ %:p |
        \ else |
        \   compiler ruby | setl makeprg=ruby\ -w\ %:p |
        \   setl errorformat=%+I%.%# |
        \ endif
endif


autocmd FileType markdown
      \ setl makeprg=open\ -a\ Marked\ %:p |
      \ setl errorformat=%+I%.%#

autocmd FileType swift
      \ setl makeprg=xcrun\ swift\ -i\ %:p |
      \ setl errorformat=%+I%.%#

command! FileDispatch execute 'FocusDispatch ' . join(map(split(&makeprg), 'expand(v:val)'))
